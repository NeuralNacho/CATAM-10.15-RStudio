crossval <- function(T, sparse_estimator) {
  # sparse_estimator is a function. e.g. bestsubset or greedysubset
  Y <- T[[1]]
  X <- T[[2]]
  p <- ncol(X)
  N <- nrow(X)
  
  # Generate the folds in the data:
  folds <- list()
  fold_complements <- list()
  random_permutation <- sample(c(1:N), N)
  n <- 1
  for (k in 1:10) {
    Y_fold <- c()  # This is the y vector we add for the new fold
    X_fold <- matrix(nrow = 0, ncol = p)
    Y_complement <- Y # This will be the complement of Y_fold
    X_complement <- X
    entries_to_remove <- c() # Will use this to make Y_complement
    while (n <= k * N / 10) {
      pi_n <- random_permutation[n]
      entries_to_remove <- append(entries_to_remove, pi_n)
      y_perm <- Y[pi_n]
      x_perm <- X[pi_n, ] # accesses row of X
      Y_fold <- append(Y_fold, y_perm)
      X_fold <- rbind(X_fold, x_perm)
      n <- n + 1
    }
    Y_complement <- Y_complement[-entries_to_remove]
    X_complement <- X_complement[-entries_to_remove,]
    new_fold <- list(Y_fold, X_fold)
    new_complement <- list(Y_complement, X_complement)
    folds[[k]] <- new_fold
    fold_complements[[k]] <- new_complement
  }
  
  # Use the sparse estimator to find the matrix B 
  # (as in Question 4) using the complement of each
  # fold as training data:
  B_matrix_list <- list() 
  # ^ list of B matrix generated by the sparse estimator
  # using the 10 different fold complements
  for (k in 1:10) {
    complement_fold <- fold_complements[[k]]
    B <- sparse_estimator(complement_fold)
    B_matrix_list[[k]] <- B
  }
  
  # Find j* based on estimated prediction error:
  j_star <- 1
  best_prediction_error <- Inf
  for (j in 1:p) {
    prediction_error <- 0
    for (k in 1:10) {
      Y_k <- folds[[k]][[1]]
      X_k <- folds[[k]][[2]]
      B <- B_matrix_list[[k]]
      beta_jk <- B[,j]  # jth column of b matrix
      RSS <- t(Y_k - X_k %*% beta_jk) %*% 
                (Y_k - X_k %*% beta_jk) / (length(Y_k))
      prediction_error <- prediction_error + RSS
    }
    prediction_error < prediction_error / 10
    if (prediction_error < best_prediction_error) {
      best_prediction_error <- prediction_error
      j_star <- j
    }
  }
  
  B <- sparse_estimator(T)
  # B matrix on entire data set
  beta_cv <- B[, j_star]
  # Assume question means to find beta_cv using the sparse estimator
  # still considering that's what was used to find j*
  # Otherwise use best_subset just for subsets of size j.
  
  return(beta_cv)
}

# Code for sample output:
# source('Q6_crossval.R')
# source('Q2_simulate_dataset.R')
# source('Q4_greedysubset.R')
# T <- simulate_dataset(100)
# print(crossval(T, greedysubset))



